
using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Threading;
using Fiddler;
using System.Diagnostics;

namespace Demo
{
    class Program
    {
        static Proxy oSecureEndpoint;
        public static string sSecureEndpointHostname;
        static int iSecureEndpointPort = 7777;
        public static void DoQuit()
        {
            if (null != oSecureEndpoint) oSecureEndpoint.Dispose();
            Fiddler.FiddlerApplication.Shutdown();
            Thread.Sleep(500);
        }
        private static string Ellipsize(string s, int iLen)
        {
            if (s.Length <= iLen) return s;
            return s.Substring(0, iLen - 3) + "...";
        }
        private static void WriteSessionList(List<Fiddler.Session> oAllSessions)
        {
            try
            {
                System.IO.StreamWriter streamx = new System.IO.StreamWriter(AppDomain.CurrentDomain.BaseDirectory + "logs.txt");
                Monitor.Enter(oAllSessions);
                foreach (Session oS in oAllSessions)
                {
                    streamx.WriteLine(Ellipsize(oS.fullUrl, 500));
                  streamx.WriteLine(oS.oRequest .headers .ToString ());
                   streamx.WriteLine("Response Code: " + oS.responseCode);
                   streamx.WriteLine("-------------------------------------------------------------------");
                 
                }
            streamx.Close();

            }
            finally
            {
                Monitor.Exit(oAllSessions);
            }
            }

        static void Main(string[] args)
        {
            sSecureEndpointHostname = args[0];
            int port;
            int.TryParse(args[1], out port);
            int sec;
            int.TryParse(args[2], out sec);
            
            List<Fiddler.Session> oAllSessions = new List<Fiddler.Session>();
            #region AttachEventListeners
            Fiddler.FiddlerApplication.OnNotification += delegate(object sender, NotificationEventArgs oNEA) { Console.WriteLine("** NotifyUser: " + oNEA.NotifyString); };
            Fiddler.FiddlerApplication.Log.OnLogString += delegate(object sender, LogEventArgs oLEA) { Console.WriteLine("** LogString: " + oLEA.LogString); };
            Fiddler.FiddlerApplication.BeforeRequest += delegate(Fiddler.Session oS)
            {
                oS.bBufferResponse = false;
                Monitor.Enter(oAllSessions);
                oAllSessions.Add(oS);
                Monitor.Exit(oAllSessions);
                oS["X-AutoAuth"] = "(default)";
               

                if ((oS.oRequest.pipeClient.LocalPort == iSecureEndpointPort) && (oS.hostname == sSecureEndpointHostname))
                {
                    oS.utilCreateResponseAndBypassServer();
                    oS.oResponse.headers.HTTPResponseStatus = "200 Ok";
                    oS.oResponse["Content-Type"] = "text/html; charset=UTF-8";
                    oS.oResponse["Cache-Control"] = "private, max-age=0";
                    oS.utilSetResponseBody("<html><body>Request for httpS://"+sSecureEndpointHostname+ ":" + iSecureEndpointPort.ToString() + " received. Your request was:<br /><plaintext>" + oS.oRequest.headers.ToString());
                }
            };
                    
            Fiddler.FiddlerApplication.AfterSessionComplete += delegate(Fiddler.Session oS)
            {
                Console.Title = ("Session list contains: " + oAllSessions.Count.ToString() + " sessions");
            };
            Console.CancelKeyPress += new ConsoleCancelEventHandler(Console_CancelKeyPress);
            #endregion AttachEventListeners
            Console.WriteLine(String.Format("Starting {0} ({1})...", Fiddler.FiddlerApplication.GetVersionString(), "FIDDLER"));

            Fiddler.CONFIG.IgnoreServerCertErrors = false;
            FiddlerApplication.Prefs.SetBoolPref("fiddler.network.streaming.abortifclientaborts", true);
            FiddlerCoreStartupFlags oFCSF = FiddlerCoreStartupFlags.Default;
            oFCSF = (oFCSF | FiddlerCoreStartupFlags.DecryptSSL);
             oFCSF = (oFCSF & ~FiddlerCoreStartupFlags.RegisterAsSystemProxy);
             int iPort = port;
            Fiddler.FiddlerApplication.Startup(iPort, oFCSF);
                        FiddlerApplication.Log.LogFormat("Proxy Listening on port {0}", iPort);
                        FiddlerApplication.Log.LogFormat("Starting with settings: [{0}]", oFCSF);
            FiddlerApplication.Log.LogFormat("Gateway: {0}", CONFIG.UpstreamGateway.ToString());
            oSecureEndpoint = FiddlerApplication.CreateProxyEndpoint(iSecureEndpointPort, true, sSecureEndpointHostname);
            if (null != oSecureEndpoint)
            {
                FiddlerApplication.Log.LogFormat("Created secure endpoint listening on port {0}, using a HTTPS certificate for '{1}'", iSecureEndpointPort , sSecureEndpointHostname);
            }
             
                        WriteSessionList(oAllSessions);
                
                        try
                        {
                           Console .WriteLine ("Result: " + Fiddler.CertMaker.trustRootCert().ToString());
                        }
                        catch (Exception eX)
                        {
                            Console.WriteLine("Failed: " + eX.ToString());
                        }

                        Stopwatch watch = new Stopwatch();
                        watch.Start();
                 
                        for (int i = 1; i <=900000;i++ )
                        {
                            if(watch .Elapsed  >TimeSpan .FromSeconds (sec))
                            {
                                break;
                            }
                            
                            Thread.Sleep(1000);
                        }
                        watch.Stop();
                        WriteSessionList(oAllSessions);
                        DoQuit();
                        
        }
        /// <summary>
        /// When the user hits CTRL+C, this event fires.  We use this to shut down and unregister our FiddlerCore.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        static void Console_CancelKeyPress(object sender, ConsoleCancelEventArgs e)
        {
            DoQuit();
        }
    }
}

